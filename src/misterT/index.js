'use strict';

const moment = require('moment');
const _ = require('lodash');
const cron = require('node-cron');
const extend = require('util')._extend
const lastBusinessDay = require('../businessDays').last;

const sessions = {};

module.exports = (controller, params) => {

  const redmine = require('../redmine')(params.redmineUrl, params.redmineApiKey);
  const wit = require('./wit')(params.witServerToken)

  return {
    warnAboutTimeSheet(bot, users) {
      _.forEach(users, (slackId, redmineId) => {
        const day = lastBusinessDay(moment()).format('YYYY-MM-DD');
        redmine.timeSheet.retrieveLog((err, hours) => {
          if(hours < 8) {
            bot.say({
              text: `Yesterday you have logged ${hours} hours\nTeachin' fools some basic rules! `,
              channel: slackId
            });
          }
        }, redmineId, day, day);
      })
    },

    appear(controller) {
      controller.hears([ 'uptime', 'identify yourself', 'who are you', 'what is your name' ],
        'direct_message,direct_mention,mention', function (bot, message) {
          const uptime = formatUptime(process.uptime());
          bot.reply(message,
            ':robot_face: I am <@' + bot.identity.name +
            '>. I have kicked asses for ' + uptime + ' now');
        });

      controller.hears(['.*'], 'direct_message,direct_mention,mention', (bot, message) => {
        //Avoid text payload generated by buttons in Facebook Messenger
        if (message.text && message.text.indexOf("_") == -1 && !message.bot_id && !message.payload && !message.attachments && !message.quick_reply) {

          bot.api.users.info({ user: message.user }, (error, response) => {
            bot.startConversation(message, (err, conv) => {
              const sessionId = findOrCreateSession(response.user.name)
              wit.runActions(sessionId, message.text, extend(
                {
                  conversation: () => conv,
                  user: `@${response.user.name}`
                },
                sessions[ sessionId ].context)
              )
                .then(context => {
                  sessions[ sessionId ].context = context;
                  next();
                })
                .catch(err => {
                  next();
                })
            })

          })

        } else {
          message.entities = {};
          next();
        }
      })
    }
  }
};

function formatUptime (uptime) {
  let unit = 'second';
  if (uptime > 60) {
    uptime = uptime / 60;
    unit = 'minute';
  }
  if (uptime > 60) {
    uptime = uptime / 60;
    unit = 'hour';
  }
  if (uptime != 1) {
    unit = unit + 's';
  }

  uptime = uptime + ' ' + unit;
  return uptime;
}

function findOrCreateSession(userId) {
  let sessionId;
  // Let's see if we already have a session for the user fbid
  Object.keys(sessions).forEach(k => {
    if (sessions[ k ].user_id === userId) {
      // Yep, got it!
      sessionId = k;
    }
  });
  if (!sessionId) {
    // No session found for user fbid, let's create a new one
    sessionId = `${userId}-${new Date().toISOString()}`;
    sessions[ sessionId ] = { fbid: userId, context: {} };
  }
  return sessionId;
}